# Practice 3 ASTのパース2 二項演算

次に単純な二項演算を実装していきましょう。`1 + 1` とか、`a * 2 / b` とかそんなやつです。

まだまだ序盤ですが、実はここの実装が最難関と言っても過言ではありません！心してかかりましょう

## 二項演算のパース

二項演算のパースはとても難しいです。`1 + 2 * 3`という式があったとき、`2 * 3`から計算することについて考えてみます。

おそらく小学校を出ているあなたには造作のない話かもしれませんが、残念ながら計算機は教育を受けていません。

演算子の優先順位を考慮してあげる必要があるのです。

## Operator-Precedence Parsing

この問題を正しく扱うために[Operator Precedence Parsing](https://en.wikipedia.org/wiki/Operator-precedence_parser)というアルゴリズムを採用しています。
 
これは各演算子に優先度を持たせ、それらの優先度比較を再帰的に行って処理をする手法です。

各オペレーターは処理の優先度を持っています。当然乗除の方が高く設定されています。

```swift
let `operator`: BinaryExpressionNode.Operator = .addition
operator.precedence
```

この優先度が高い方の二項を探索し、再帰的にツリーを生成していくのです。

## Operator Precedence Parsing実践編

`parseBinaryOperatorRHS`は現在の式の優先度と左辺から適切な右辺を取り出すための関数です。

```swift
func parseBinaryOperatorRHS(expressionPrecedence: Int, lhs: Node)
```

これを再帰的に適応していくことで、複雑な数式をパースすることができます。

例えば`a + b * c`を考えてみましょう。


まず最初に`a`がパースされ、次に続くオペレーター`+`を共有する右辺を探します。
`a + b`が候補として上がりますが、`b`はさらにその先を探索するために、`parseBinaryOperatorRHS`を再帰的に呼び出します。
その結果、`*`の優先順位は`+`より高いので、右辺は組み替えられ、`b * c`となります。


これで逆ポーランド記法で言うところの、`a b c * +`という計算順序にパースすることができます。

## 3-1. オペレータのパース

まず手始めにオペレータのトークンからオペレータを生成します。

`extractBinaryOperator`を実装してみてください。注意点として、今回は未知のトークンが来た場合に`Operator?`として返す点です。

後の実装では、オペレータが見つからなかった場合は、優先度-1として扱っています。その方が都合が良いのです。

## 3-2〜3-5. いろいろな演算

わかりましたか？私はすぐにわかりませんでした。

今回はあんまりにも難しいので、予め実装を用意しておきました。
3-1が正しく実装できると、これらのテストケースは全て通るはずです！
数学的に正しい演算がされていることを確認してみましょう。

`()`の扱い方なんて習ってないよ！大丈夫、私が実装しておきました。

気になる方は`parseParen`を見てみましょう。`(`(`leftParen`)が現れたら、`parseExpression`で中身を取り出し、最後に`)`(`rightParen`)で終了することを確認しています。

今後、再帰的に`parseExpression`を呼んで、式を取り出す実装は頻繁に登場します。悩んだら思い出してみてください。

